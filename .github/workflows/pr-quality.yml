name: PR Quality

on:
  pull_request:
    branches: [ main, master ]

permissions:
  contents: read
  pull-requests: write
  checks: write
  statuses: write
  actions: read
  security-events: write

jobs:
  unit:
    name: Unit tests with coverage
    runs-on: ubuntu-latest
    outputs:
      lines: ${{ steps.coverage_summary.outputs.lines }}
      statements: ${{ steps.coverage_summary.outputs.statements }}
      branches: ${{ steps.coverage_summary.outputs.branches }}
      functions: ${{ steps.coverage_summary.outputs.functions }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v6
        with:
          node-version: lts/*
          cache: 'npm'
      - name: Install dependencies
        run: npm ci
      - name: Run unit tests with coverage
        id: unit_tests
        run: npm run test -- --coverage --coverageReporters=lcov --coverageReporters=json-summary
      - name: Extract coverage summary
        id: coverage_summary
        if: ${{ always() && hashFiles('coverage/coverage-summary.json') != '' }}
        run: |
          node <<'EOF'
          const fs = require('fs');
          const summaryPath = 'coverage/coverage-summary.json';
          if (!fs.existsSync(summaryPath)) {
            console.log('coverage-summary.json not found');
            process.exit(0);
          }
          const total = JSON.parse(fs.readFileSync(summaryPath, 'utf8')).total;
          const toPct = (section) => Number.parseFloat((section?.pct ?? 0).toFixed(2));
          const lines = toPct(total.lines);
          const statements = toPct(total.statements);
          const branches = toPct(total.branches);
          const functions = toPct(total.functions);
          const outputs = { lines, statements, branches, functions };
          for (const [key, value] of Object.entries(outputs)) {
            console.log(`${key}=${value}`);
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `${key}=${value}\n`);
          }
          EOF
      - name: Upload coverage artifact
        if: ${{ always() && hashFiles('coverage/lcov-report/index.html') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: unit-report
          path: coverage/lcov-report
          retention-days: 14

  security:
    name: Security checks
    runs-on: ubuntu-latest
    outputs:
      trivy_summary: ${{ steps.trivy_summary.outputs.summary }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Trufflehog - Changes
        uses: trufflesecurity/trufflehog@main
        with:
          extra_args: --only-verified
      - name: Run Trivy vulnerability scanner in repo mode
        uses: aquasecurity/trivy-action@0.34.1
        with:
          scan-type: 'fs'
          scan-ref: '.'
          ignore-unfixed: true
          format: table
          severity: 'CRITICAL'
          exit-code: 0
      - name: Run Trivy vulnerability scanner in repo mode (JSON)
        id: trivy_json
        uses: aquasecurity/trivy-action@0.34.1
        with:
          scan-type: 'fs'
          scan-ref: '.'
          ignore-unfixed: true
          format: json
          output: trivy-results.json
          severity: 'HIGH,CRITICAL,MEDIUM,LOW,UNKNOWN'
          exit-code: 0
      - name: Summarize Trivy findings
        id: trivy_summary
        run: |
          node <<'EOF'
          const fs = require('fs');
          const path = 'trivy-results.json';
          if (!fs.existsSync(path)) {
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `summary=unavailable\n`);
            process.exit(0);
          }
          const data = JSON.parse(fs.readFileSync(path, 'utf8'));
          // Newer Trivy JSON aggregates in Results[].Vulnerabilities
          const counts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, UNKNOWN: 0 };
          const add = (sev) => { if (counts[sev] !== undefined) counts[sev] += 1; };
          (data.Results || []).forEach(r => (r.Vulnerabilities || []).forEach(v => add(v.Severity)));
          const summary = Object.entries(counts)
            .filter(([, v]) => v > 0)
            .map(([k, v]) => `${k}: ${v}`)
            .join(', ') || 'no issues';
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `summary=${summary}\n`);
          EOF

  e2e:
    name: Playwright E2E
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v6
        with:
          node-version: lts/*
          cache: 'npm'
      - name: Install dependencies
        run: npm ci
      - name: Install Playwright Browsers
        run: npx playwright install --with-deps
      - name: Run Playwright tests
        id: e2e_tests
        run: npm run test:e2e:cli:chrome
      - name: Upload Playwright report
        if: ${{ always() && hashFiles('playwright-report/index.html') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: playwright-report
          retention-days: 14

  build:
    name: Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v6
        with:
          node-version: lts/*
          cache: 'npm'
      - name: Install dependencies
        run: npm ci
      - name: Build app
        run: npm run build
      - name: Upload dist artifact
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: dist
          retention-days: 1

  ready-for-deploy:
    name: Ready for Deploy
    needs: [unit, e2e, build]
    runs-on: ubuntu-latest
    steps:
      - run: echo "Artifacts are ready and tests passed."

  comment:
    name: Comment on PR
    needs: [unit, e2e, build, security]
    runs-on: ubuntu-latest
    if: ${{ always() && github.event.pull_request }}
    steps:
      - name: Post combined report comment
        uses: actions/github-script@v8
        env:
          UNIT_STATUS: ${{ needs.unit.result }}
          E2E_STATUS: ${{ needs.e2e.result }}
          BUILD_STATUS: ${{ needs.build.result }}
          SECURITY_STATUS: ${{ needs.security.result }}
          TRIVY_SUMMARY: ${{ needs.security.outputs.trivy_summary }}
          COV_LINES: ${{ needs.unit.outputs.lines }}
          COV_BRANCHES: ${{ needs.unit.outputs.branches }}
          COV_FUNCTIONS: ${{ needs.unit.outputs.functions }}
          COV_STATEMENTS: ${{ needs.unit.outputs.statements }}
        with:
          script: |
            const marker = 'ðŸ§ª Test reports for this PR';
            const unitStatus = process.env.UNIT_STATUS || 'unknown';
            const e2eStatus = process.env.E2E_STATUS || 'unknown';
            const buildStatus = process.env.BUILD_STATUS || 'unknown';
            const cov = {
              lines: process.env.COV_LINES,
              branches: process.env.COV_BRANCHES,
              functions: process.env.COV_FUNCTIONS,
              statements: process.env.COV_STATEMENTS,
            };
            const trivy = process.env.TRIVY_SUMMARY || 'unavailable';
            const formatCov = () => {
              const entries = Object.entries(cov).filter(([, v]) => v !== '' && v != null);
              if (!entries.length) return 'coverage unavailable';
              return entries.map(([k, v]) => `${k}: ${v}%`).join(', ');
            };
            const lines = [
              marker,
              `- Build: **${buildStatus}**`,
              `- Unit tests: **${unitStatus}**`,
              `  - Coverage: ${formatCov()}`,
              `- E2E tests: **${e2eStatus}**`,
              `- Security (Trivy/Trufflehog): **${process.env.SECURITY_STATUS || 'unknown'}** â€” ${trivy}`,
              `---`,
              `_Note: Preview deployment will start once checks pass._`
            ];
            const body = lines.join('\n');

            const { owner, repo } = context.repo;
            const issue_number = context.issue.number;
            const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number });
            const existing = comments.find(c => c.user?.login === 'github-actions[bot]' && c.body?.includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existing.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body
              });
            }

